"""
Triangle, pentagonal, and hexagonal numbers
are generated by the following formulae:
Triangle 	  	T_n = n(n+1)/2 	  	1, 3, 6, 10, 15, ...
Pentagonal 	  	P_n = n(3n−1)/2 	1, 5, 12, 22, 35, ...
Hexagonal 	  	H_n = n(2n−1) 	  	1, 6, 15, 28, 45, ...

It can be verified that
T_285 = P_165 = H_143 = 40755.

Find the next triangle number that is also
pentagonal and hexagonal.
"""

"""
As we do not have an upper bound, we need to
go forward step by step. We know that the number
we are looking for is above 40755 and we are given
the indices of this number in the three sequences.
We write three generators. All of them start one
index above their index of 40755 and gives us
with the next(g) the next element in their sequence.
We create upper bounds dynamically and compute all
elements in the three lists seperately up to our bound.
(It bounds the value, not the indices!)
If we did not find any number which is in all three
lists, we throw them away and create a new upper bound
with new lists. The steps we take for the bound gets
bigger everytime we create the lists. We save a lot of
storage and computing time with that, but most importantly
we need to do this as we do not have a global upper
bound.
"""

def sol():
    # Write three generators starting at their indices of
    # the last number with the condition plus 1.
    def triangle():
        n = 286
        while True:
            yield n*(n+1)/2
            n += 1
    def pentagonal():
        n = 166
        while True:
            yield n*(3*n-1)/2
            n+=1
    def hexagonal():
        n = 144
        while True:
            yield n*(2*n-1)
            n += 1
    
    # Create three generators and fill the lists with first element
    tri = triangle()
    l1 = [next(tri)]
    pen = pentagonal()
    l2 = [next(pen)]
    hex = hexagonal()
    l3 = [next(hex)]

    # n is the multiplier of 1000, n*1000 raises the upper bound
    n = 1

    # Our first upper bound is 41k, starting from the last hit (excluding)
    max_value = 41000

    # We start loop, which ends if we get a hit
    while True:

        # Clean the lists and fill with the next bunch of sequence elements
        l1 = l1[-1:]
        while l1[-1] < max_value:
            l1.append(next(tri))

        l2 = l2[-1:]
        while l2[-1] < max_value:
            l2.append(next(pen))

        l3 = l3[-1:]
        while l3[-1] < max_value:
            l3.append(next(hex))
        
        # Check if there is any element occuring in all three lists
        for candidate in l1:
            if candidate in l2 and candidate in l3:
                return candidate
        
        # Raise the upper bound by a increasing multiply of 1000
        max_value += n * 1000
        n += 1


print(sol())
