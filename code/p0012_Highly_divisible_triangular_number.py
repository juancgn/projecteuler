"""
The sequence of triangle numbers is generated by adding the natural numbers.
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:
     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.
What is the value of the first triangle number to have over five hundred divisors?
"""

"""
We create a generator for the triangle numbers and create a loop, where we take 
them one by one and compute their number of divisors. How many divisors does a
integer have?

Lets take a number n, one of its divisors d and the counterpart d', meaning
that we have d * d' = n. Every number has such a factorization, for example
1 * n = n. We see, that the prime factorization of d must be part of the
factorization of n, meaning that every prime factor of d occurs as least as
often as in the prime factorization of n like in this of d. That is because
if d divides n, all of its divisors divides n too, obviously - including its 
prime divisors. But then, these prime divisors must occur in the prime
factorization of n. On the other hand, if all prime divisors of d occurs
in the prime factorization of n, d divides n.

This fact is useful because now we can just compute the prime factorization
of n and we get all the divisors by determining every possible subset of
them and multiplying the prime numbers in it. Actually, we do not even need
to compute the divisors explicitly since the exercise is just to find out
how many of them exists. And this is quite easy.

Lets say we have k prime divisors with occurences a_1, ..., a_k.
A subset of these prime divisors could include, for example, the
first prime divisor 0 times up to a_1 times, hence a_1 + 1 times,
the second prime divisor a_2 + 1 times, the third prime divisor
a_3 + 1 times etc. Therefore, there are (a_1 + 1) * ... * (a_k + 1)
possible combinations and just as many divisors. And this is
the simple formula we need to compute.
"""

from useful_funcs import get_prime_divisors


def sol():
    def triangle_number_generator():
        # A generator which adds the next number to the sum and returns that sum
        s = 0
        n = 0
        while True:
            n += 1
            s += n
            yield s

    triangle_generator = triangle_number_generator()

    # We create a variable to store the set of divisors of the currently considered triangle number
    triangle_number = 0
    num_divisors = 1

    # Compute the number of divisors of the triangle numbers until we found one with more than or equal 500 divisors
    while num_divisors < 500:

        # Get the next triangle number
        triangle_number = next(triangle_generator)

        # Compute all prime divisors
        prime_divisors = get_prime_divisors(triangle_number)

        # Count divisors
        num_divisors = 1
        for i in set(prime_divisors):
            num_divisors *= (prime_divisors.count(i) + 1)

    # If the loop is finished, the last triangle number has more or equal 500 divisors
    return triangle_number


print(sol())
